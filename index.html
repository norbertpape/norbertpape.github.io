<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Norbert Pape</title>
    <link rel="stylesheet" href="styles/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="canonical" href="https://norbertpape.github.io/" />
    <meta name="viewport" content="width =device-width, initial-scale=1.0">
    <meta name="description" content="Personal website of Norbert Pape">
    <meta name="keywords" content="Norbert Pape, dance, art, choreography, VR, performance, augmented reality, contemporary art, virtual reality, unity, quest, oculus, pedagogy, self-organisation" />
    <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$']] } }); </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config =TeX-AMS-MML_HTMLorMML"></script>
</head>
  <body>
    <main>
        <script src="menu.js"></script>
    </main>
	<video class="fullscreen-video" autoplay="autoplay" muted loop>
		<source src="/images/GrassWind.mp4" type="video/mp4">
		Your browser does not support the video tag.
	</video>
  <!--
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js"
            }
        }
    </script>
	<script type="module">

        import * as THREE from 'https://unpkg.com/three@0.156.1/build/three.module.js'
        import { OrbitControls } from 'https://unpkg.com/three@0.156.1/examples/jsm/controls/OrbitControls.js';


        let renderer, scene, camera;

        let line;

        const GRID_WIDTH = 200;
        const GRID_LENGTH = 200;
        const UNIT = 0.1;
        const MAX_POINTS = GRID_WIDTH*GRID_LENGTH*3;

        let t = 0;

        init();
        animate();

        function init() {
            // info
            const info = document.createElement( 'div' );
            info.style.position = 'absolute';
            info.style.top = '30px';
            info.style.width = '100%';
            info.style.textAlign = 'center';
            info.style.color = '#fff';
            info.style.fontWeight = 'bold';
            info.style.backgroundColor = 'transparent';
            info.style.zIndex = '1';
            info.style.fontFamily = 'Monospace';
            //info.innerHTML = "three.js plotting 3D functions";
            document.body.appendChild( info );
            // renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            // scene
            scene = new THREE.Scene();
            // camera
            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set( 150,-375,-175 );
            const controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = true;
            // geometry
            const geometry = new THREE.BufferGeometry();
            // attributes
            const positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
            geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            // material
            const material = new THREE.PointsMaterial( { color: 0xffffff } );
            // line
            line = new THREE.Points( geometry,  material );
            scene.add( line );
            // update positions
            updatePositions();
        }

        // update positions
        function updatePositions() {
	        const positions = line.geometry.attributes.position.array;
	        let index = 0;
	        for ( let i = 0, l = GRID_WIDTH; i < l; i ++ ) {
		        for ( let j = 0, l = GRID_WIDTH; j < l; j ++ ) {
			        positions[ index ++ ] = i*2 - GRID_WIDTH;
			        positions[ index ++ ] = j*2 - GRID_WIDTH;
			        positions[ index ++ ] = Math.sin(i/GRID_WIDTH*2*Math.PI)* Math.sin(j/GRID_WIDTH*2*Math.PI)*Math.sin(2*t)*80;
		        }
	        }
        }

        // render
        function render() {
            renderer.render( scene, camera );
        }

        // animate
        function animate() {
	        requestAnimationFrame( animate );
	        t = (t + 0.01) % Math.PI;
	        updatePositions();
	        line.geometry.attributes.position.needsUpdate = true; // required after the first render
	        render();
        }
	</script> -->
  </body>
</html>
